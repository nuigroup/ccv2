<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!--
Syntax highlighting generated by Web C Plus Plus software v0.8.4
Webcpp Copyright (C)2001-2004 Jeffrey Bakker under the GNU GPL
Get webcpp at http://webcpp.sf.net
-->

<html>
<head>
<title>pstreams.h</title>
<style type="text/css">

/*
Webcpp v0.8.1 compatible StyleSheet
http://webcpp.sf.net
Theme: ide-msvcpp
*/

body
{
background-color: #ffffff
}

.webcpp a:link    {color:#000000}
.webcpp a:visited {color:#008000}
.webcpp a:active  {color:#0000ff}
.webcpp a:hover   {color:#0000ff}

.webcpp pre
{
color: #000000
}

.webcpp font
{
font-size:100%
}

.webcpp .symbols
{
color: #000000
}

.webcpp .preproc
{
color: #0000ff
}

.webcpp .integer
{
color: #000000
}

.webcpp .floatpt
{
color: #000000
}

.webcpp .dblquot
{
color: #000000
}

.webcpp .sinquot
{
color: #000000
}

.webcpp .keyword
{
color: #0000ff;

}

.webcpp .keytype
{
color: #0000ff;

}

.webcpp .comment
{
color: #008000;

}

</style>
</head>
<body bgcolor="#FFFFFF" leftmargin="40" marginwidth="40"> <p><a href="../htsrc.html">Index</a><hr noshade></p>

<div class="webcpp">
<pre>


<font CLASS=preproc>#ifndef</font> __PSTREAMS_H__ 
<font CLASS=preproc>#define</font> __PSTREAMS_H__ 

<font CLASS=preproc>#ifndef</font> __PPORT_H__ 
<font CLASS=preproc>#include</font> <font CLASS=dblquot>"pport.h"</font> 
<font CLASS=preproc>#endif</font> 

<font CLASS=preproc>#ifndef</font> __PTYPES_H__ 
<font CLASS=preproc>#include</font> <font CLASS=dblquot>"ptypes.h"</font> 
<font CLASS=preproc>#endif</font> 

<font CLASS=preproc>#ifndef</font> PTYPES_ST 
<font CLASS=preproc>#</font>  ifndef __PASYNC_H__ 
<font CLASS=preproc>#</font>    include <font CLASS=dblquot>"pasync.h"</font>  <font CLASS=comment>// for logfile.lock </font>
<font CLASS=preproc>#</font>  endif 
<font CLASS=preproc>#endif</font> 

<font CLASS=preproc>#include</font> &lt;stdarg.h&gt; 
<font CLASS=preproc>#include</font> &lt;errno.h&gt; 


<font CLASS=preproc>#ifdef</font> WIN32 
<font CLASS=preproc>#</font>  define _WINSOCKAPI_   <font CLASS=comment>// prevent inclusion of winsock.h, because we need winsock2.h </font>
<font CLASS=preproc>#</font>  include <font CLASS=dblquot>"windows.h"</font>   <font CLASS=comment>// for OVERLAPPED </font>
<font CLASS=preproc>#endif</font> 


PTYPES_BEGIN


<font CLASS=preproc>#ifdef</font> _MSC_VER 
<font CLASS=preproc>#pragma</font> pack(push, <font CLASS=integer>4</font>) 
<font CLASS=preproc>#endif</font> 


<font CLASS=comment>// -------------------------------------------------------------------- //</font>
<font CLASS=comment>// ---  abstract stream i/o classes ----------------------------------- //</font>
<font CLASS=comment>// -------------------------------------------------------------------- //</font>


<font CLASS=comment>//</font>
<font CLASS=comment>// stream exception class</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> iobase;

<font CLASS=keyword>class</font> estream: public exception 
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    <font CLASS=keytype>int</font> code;
    iobase* errstm;
<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    estream(iobase* ierrstm, <font CLASS=keytype>int</font> icode, <font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* imsg);
    estream(iobase* ierrstm, <font CLASS=keytype>int</font> icode, <font CLASS=keyword>const</font> string&amp; imsg);
    <font CLASS=keyword>virtual</font> ~estream();
    <font CLASS=keytype>int</font> get_code()          { <font CLASS=keyword>return</font> code; }
    iobase* get_errstm()    { <font CLASS=keyword>return</font> errstm; }
};


<font CLASS=keyword>typedef</font> <font CLASS=keytype>void</font> (*iostatusevent)(iobase* sender, <font CLASS=keytype>int</font> code);

<font CLASS=keytype>int</font> unixerrno();
<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* unixerrmsg(<font CLASS=keytype>int</font> code);


<font CLASS=comment>// status codes: compatible with WinInet API</font>
<font CLASS=comment>// additional status codes are defined in pinet.h for ipsocket</font>

<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> IO_CREATED <font CLASS=symbols>=</font> <font CLASS=integer>1</font>;
<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> IO_OPENING <font CLASS=symbols>=</font> <font CLASS=integer>5</font>;
<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> IO_OPENED <font CLASS=symbols>=</font> <font CLASS=integer>35</font>;
<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> IO_READING <font CLASS=symbols>=</font> <font CLASS=integer>37</font>;
<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> IO_WRITING <font CLASS=symbols>=</font> <font CLASS=integer>38</font>;
<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> IO_EOF <font CLASS=symbols>=</font> <font CLASS=integer>45</font>;
<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> IO_CLOSING <font CLASS=symbols>=</font> <font CLASS=integer>250</font>;
<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> IO_CLOSED <font CLASS=symbols>=</font> <font CLASS=integer>253</font>;


<font CLASS=comment>//</font>
<font CLASS=comment>// iobase</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>enum</font> ioseekmode 
{
    IO_BEGIN,
    IO_CURRENT,
    IO_END
};


<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> invhandle <font CLASS=symbols>=</font> <font CLASS=symbols>-</font><font CLASS=integer>1</font>;


<font CLASS=keyword>class</font> iobase: public component 
{
    <font CLASS=keyword>friend</font> <font CLASS=keyword>class</font> fdxoutstm;

<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    <font CLASS=keytype>bool</font>    active;         <font CLASS=comment>// active status, changed by open() and close()</font>
    <font CLASS=keytype>bool</font>    cancelled;      <font CLASS=comment>// the stream was cancelled by cancel()</font>
    <font CLASS=keytype>bool</font>    eof;            <font CLASS=comment>// end of file reached, only for input streams</font>
    <font CLASS=keytype>int</font>     handle;         <font CLASS=comment>// used in many derivative classes</font>
    large   abspos;         <font CLASS=comment>// physical stream position</font>
    <font CLASS=keytype>int</font>     bufsize;        <font CLASS=comment>// buffer size, can be changed only when not active</font>
    <font CLASS=keytype>char</font>*   bufdata;        <font CLASS=comment>// internal: allocated buffer data</font>
    <font CLASS=keytype>int</font>     bufpos;         <font CLASS=comment>// internal: current position</font>
    <font CLASS=keytype>int</font>     bufend;         <font CLASS=comment>// internal: current data size in the buffer</font>
    <font CLASS=keytype>int</font>     stmerrno;       <font CLASS=comment>// UNIX-compatible error numbers, see comments in piobase.cxx</font>
    string  deferrormsg;    <font CLASS=comment>// internal: default error message when an exception is thrown,</font>
    <font CLASS=keytype>int</font>     status;         <font CLASS=comment>// stream status code, see IO_xxx constants above</font>
    iostatusevent onstatus; <font CLASS=comment>// user-defined status change handler</font>

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> bufalloc();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> buffree();
    <font CLASS=keytype>void</font> bufclear() { bufpos <font CLASS=symbols>=</font> <font CLASS=integer>0</font>; bufend <font CLASS=symbols>=</font> <font CLASS=integer>0</font>; }

    <font CLASS=keytype>void</font> errstminactive();
    <font CLASS=keytype>void</font> errbufrequired();
    <font CLASS=keytype>void</font> requireactive()        { <font CLASS=keyword>if</font> (!active) errstminactive(); }
    <font CLASS=keytype>void</font> requirebuf()           { requireactive(); <font CLASS=keyword>if</font> (bufdata <font CLASS=symbols>==</font> <font CLASS=integer>0</font>) errbufrequired(); }
    <font CLASS=keytype>int</font>  convertoffset(large);

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen() <font CLASS=symbols>=</font> <font CLASS=integer>0</font>;
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();
    <font CLASS=keyword>virtual</font> large doseek(large newpos, ioseekmode mode);

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> chstat(<font CLASS=keytype>int</font> newstat);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> uerrno();
    <font CLASS=keyword>virtual</font> <font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* uerrmsg(<font CLASS=keytype>int</font> code);

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    iobase(<font CLASS=keytype>int</font> ibufsize <font CLASS=symbols>=</font> <font CLASS=symbols>-</font><font CLASS=integer>1</font>);
    <font CLASS=keyword>virtual</font> ~iobase();

    <font CLASS=keytype>void</font> open();
    <font CLASS=keytype>void</font> close();
    <font CLASS=keytype>void</font> cancel();
    <font CLASS=keytype>void</font> reopen()                                   { open(); }
    large seekx(large newpos, ioseekmode mode <font CLASS=symbols>=</font> IO_BEGIN);
    <font CLASS=keytype>int</font> seek(<font CLASS=keytype>int</font> newpos, ioseekmode mode <font CLASS=symbols>=</font> IO_BEGIN) { <font CLASS=keyword>return</font> convertoffset(seekx(newpos, mode)); }
    <font CLASS=keytype>void</font> error(<font CLASS=keytype>int</font> code, <font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* defmsg);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> flush();

    <font CLASS=keyword>virtual</font> string get_errormsg();
    <font CLASS=keyword>virtual</font> string get_errstmname();
    <font CLASS=keyword>virtual</font> string get_streamname() <font CLASS=symbols>=</font> <font CLASS=integer>0</font>;

    <font CLASS=keytype>bool</font> get_active()                               { <font CLASS=keyword>return</font> active; }
    <font CLASS=keytype>void</font> set_active(<font CLASS=keytype>bool</font> newval);
    <font CLASS=keytype>bool</font> get_cancelled()                            { <font CLASS=keyword>return</font> cancelled; }
    <font CLASS=keytype>void</font> set_cancelled(<font CLASS=keytype>bool</font> newval)                 { cancelled <font CLASS=symbols>=</font> newval; }
    <font CLASS=keytype>int</font>  get_handle()                               { <font CLASS=keyword>return</font> handle; }
    <font CLASS=keytype>int</font>  get_bufsize()                              { <font CLASS=keyword>return</font> bufsize; }
    <font CLASS=keytype>void</font> set_bufsize(<font CLASS=keytype>int</font> newval);
    <font CLASS=keytype>int</font>  get_stmerrno()                             { <font CLASS=keyword>return</font> stmerrno; }
    <font CLASS=keytype>int</font>  get_status()                               { <font CLASS=keyword>return</font> status; }
    iostatusevent get_onstatus()                    { <font CLASS=keyword>return</font> onstatus; }
    <font CLASS=keytype>void</font> set_onstatus(iostatusevent newval)         { onstatus <font CLASS=symbols>=</font> newval; }
};
<font CLASS=keyword>typedef</font> iobase* piobase;


<font CLASS=keyword>extern</font> <font CLASS=keytype>int</font> defbufsize;
<font CLASS=keyword>extern</font> <font CLASS=keytype>int</font> stmbalance;


<font CLASS=comment>//</font>
<font CLASS=comment>// instm - abstract input stream</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>const</font> <font CLASS=keytype>char</font> eofchar <font CLASS=symbols>=</font> <font CLASS=integer>0</font>;

<font CLASS=keyword>class</font> instm: public iobase 
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> dorawread(<font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);
    <font CLASS=keytype>int</font> rawread(<font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> bufvalidate();
    <font CLASS=keytype>void</font> skipeol();

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    instm(<font CLASS=keytype>int</font> ibufsize <font CLASS=symbols>=</font> <font CLASS=symbols>-</font><font CLASS=integer>1</font>);
    <font CLASS=keyword>virtual</font> ~instm();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> classid();

    <font CLASS=keytype>bool</font> get_eof();
    <font CLASS=keytype>void</font> set_eof(<font CLASS=keytype>bool</font> ieof)     { eof <font CLASS=symbols>=</font> ieof; }
    <font CLASS=keytype>bool</font> get_eol();
    <font CLASS=keytype>int</font>  get_dataavail();
    <font CLASS=keytype>char</font> preview();
    <font CLASS=keytype>char</font> get();
    <font CLASS=keytype>void</font> putback();
    string token(<font CLASS=keyword>const</font> cset&amp; chars);
    string token(<font CLASS=keyword>const</font> cset&amp; chars, <font CLASS=keytype>int</font> limit);
    <font CLASS=keytype>int</font> token(<font CLASS=keyword>const</font> cset&amp; chars, char* buf, <font CLASS=keytype>int</font> size);
    string line();
    string line(<font CLASS=keytype>int</font> limit);
    <font CLASS=keytype>int</font> line(<font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> size, <font CLASS=keytype>bool</font> eateol <font CLASS=symbols>=</font> <font CLASS=keyword>true</font>);
    <font CLASS=keytype>int</font> read(<font CLASS=keytype>void</font>* buf, <font CLASS=keytype>int</font> count);
    <font CLASS=keytype>int</font> skip(<font CLASS=keytype>int</font> count);
    <font CLASS=keytype>int</font> skiptoken(<font CLASS=keyword>const</font> cset&amp; chars);
    <font CLASS=keytype>void</font> skipline(<font CLASS=keytype>bool</font> eateol <font CLASS=symbols>=</font> <font CLASS=keyword>true</font>);
    large tellx();
    <font CLASS=keytype>int</font> tell()  { <font CLASS=keyword>return</font> convertoffset(tellx()); }
    large seekx(large newpos, ioseekmode mode <font CLASS=symbols>=</font> IO_BEGIN);
    <font CLASS=keytype>int</font> seek(<font CLASS=keytype>int</font> newpos, ioseekmode mode <font CLASS=symbols>=</font> IO_BEGIN)   { <font CLASS=keyword>return</font> convertoffset(seekx(newpos, mode)); }
};
<font CLASS=keyword>typedef</font> instm* pinstm;


<font CLASS=comment>//</font>
<font CLASS=comment>// outstm - abstract output stream</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> outstm: public iobase 
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    <font CLASS=keytype>bool</font> flusheol;

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> dorawwrite(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);
    <font CLASS=keytype>int</font> rawwrite(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> bufvalidate();
    <font CLASS=keytype>void</font> bufadvance(<font CLASS=keytype>int</font> delta)  
        { bufpos <font CLASS=symbols>+=</font> delta; <font CLASS=keyword>if</font> (bufend &lt; bufpos) bufend <font CLASS=symbols>=</font> bufpos; }
    <font CLASS=keytype>bool</font> canwrite();

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    outstm(<font CLASS=keytype>bool</font> iflusheol <font CLASS=symbols>=</font> <font CLASS=keyword>false</font>, <font CLASS=keytype>int</font> ibufsize <font CLASS=symbols>=</font> -<font CLASS=integer>1</font>);
    <font CLASS=keyword>virtual</font> ~outstm();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> classid();

    <font CLASS=keytype>bool</font> get_flusheol()             { <font CLASS=keyword>return</font> flusheol; }
    <font CLASS=keytype>void</font> set_flusheol(<font CLASS=keytype>bool</font> newval)  { flusheol <font CLASS=symbols>=</font> newval; }

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> flush();
    <font CLASS=keytype>bool</font> get_eof()                  { <font CLASS=keyword>return</font> eof; }
    <font CLASS=keytype>void</font> put(<font CLASS=keytype>char</font> c);
    <font CLASS=keytype>void</font> put(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* str);
    <font CLASS=keytype>void</font> put(<font CLASS=keyword>const</font> string&amp; str);
    <font CLASS=keytype>void</font> vputf(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* fmt, va_list);
    <font CLASS=keytype>void</font> putf(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* fmt, ...);
    <font CLASS=keytype>void</font> putline(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* str);
    <font CLASS=keytype>void</font> putline(<font CLASS=keyword>const</font> string&amp; str);
    <font CLASS=keytype>void</font> puteol();
    <font CLASS=keytype>int</font> write(<font CLASS=keyword>const</font> <font CLASS=keytype>void</font>* buf, <font CLASS=keytype>int</font> count);
    large tellx()                   { <font CLASS=keyword>return</font> abspos <font CLASS=symbols>+</font> bufpos; }
    <font CLASS=keytype>int</font> tell()                      { <font CLASS=keyword>return</font> convertoffset(tellx()); }
    large seekx(large newpos, ioseekmode mode <font CLASS=symbols>=</font> IO_BEGIN);
    <font CLASS=keytype>int</font> seek(<font CLASS=keytype>int</font> newpos, ioseekmode mode <font CLASS=symbols>=</font> IO_BEGIN)  { <font CLASS=keyword>return</font> convertoffset(seekx(newpos, mode)); }
};
<font CLASS=keyword>typedef</font> outstm* poutstm;


<font CLASS=comment>// %t and %T formats</font>
<font CLASS=keyword>extern</font> <font CLASS=keytype>char</font>* shorttimefmt;  <font CLASS=comment>// "%d-%b-%Y %X"</font>
<font CLASS=keyword>extern</font> <font CLASS=keytype>char</font>* longtimefmt;   <font CLASS=comment>// "%a %b %d %X %Y"</font>


<font CLASS=comment>//</font>
<font CLASS=comment>// internal class used in fdxstm</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> fdxstm;


<font CLASS=keyword>class</font> fdxoutstm: public outstm
{
    <font CLASS=keyword>friend</font> <font CLASS=keyword>class</font> fdxstm;

<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    fdxstm* in;
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> chstat(<font CLASS=keytype>int</font> newstat);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> uerrno();
    <font CLASS=keyword>virtual</font> <font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* uerrmsg(<font CLASS=keytype>int</font> code);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> dorawwrite(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    fdxoutstm(<font CLASS=keytype>int</font> ibufsize, fdxstm* iin);
    <font CLASS=keyword>virtual</font> ~fdxoutstm();
    <font CLASS=keyword>virtual</font> string get_streamname();
};
<font CLASS=keyword>typedef</font> fdxstm* pfdxstm;


<font CLASS=comment>//</font>
<font CLASS=comment>// fdxstm: abstract full-duplex stream (for sockets and pipes)</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> fdxstm: public instm
{
    <font CLASS=keyword>friend</font> <font CLASS=keyword>class</font> fdxoutstm;

<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    fdxoutstm out;

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> dorawwrite(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>

    fdxstm(<font CLASS=keytype>int</font> ibufsize <font CLASS=symbols>=</font> <font CLASS=symbols>-</font><font CLASS=integer>1</font>);
    <font CLASS=keyword>virtual</font> ~fdxstm();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> classid();

    <font CLASS=keytype>void</font> set_bufsize(<font CLASS=keytype>int</font> newval);       <font CLASS=comment>// sets both input and output buffer sizes</font>

    <font CLASS=keytype>void</font> open();            <font CLASS=comment>// rewritten to pass the call to the output stream too</font>
    <font CLASS=keytype>void</font> close();
    <font CLASS=keytype>void</font> cancel();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> flush();
    large tellx(<font CLASS=keytype>bool</font>);      <font CLASS=comment>// true for input and false for output</font>
    <font CLASS=keytype>int</font> tell(<font CLASS=keytype>bool</font> forin)                    { <font CLASS=keyword>return</font> convertoffset(tellx(forin)); }

    // output interface: pretend <font CLASS=keyword>this</font> <font CLASS=keyword>class</font> is derived both
    // from instm and outstm. actually we can<font CLASS=sinquot>'t use multiple
    // inheritance here, since this is a full-duplex stream,
    // hence everything must be duplicated for input and output
    void putf(const char* fmt, ...);
    void put(char c)                        { out.put(c); }
    void put(const char* str)               { out.put(str); }
    void put(const string&amp; str)             { out.put(str); }
    void putline(const char* str)           { out.putline(str); }
    void putline(const string&amp; str)         { out.putline(str); }
    void puteol()                           { out.puteol(); }
    int  write(const void* buf, int count)  { return out.write(buf, count); }
    bool get_flusheol()                     { return out.get_flusheol(); }
    void set_flusheol(bool newval)          { out.set_flusheol(newval); }

    operator outstm&amp;()			            { return out; }
};


<font CLASS=comment>//</font>
<font CLASS=comment>// abstract input filter class</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> infilter: public instm 
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    instm*   stm;
    <font CLASS=keytype>char</font>*    savebuf;
    <font CLASS=keytype>int</font>      savecount;
    string   postponed;

    <font CLASS=keytype>void</font> copytobuf(string&amp; s);
    <font CLASS=keytype>void</font> copytobuf(pconst&amp; buf, <font CLASS=keytype>int</font>&amp; count);
    <font CLASS=keytype>bool</font> copytobuf(<font CLASS=keytype>char</font> c);

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> freenotify(component* sender);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font>  dorawread(<font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> dofilter() <font CLASS=symbols>=</font> <font CLASS=integer>0</font>;

    <font CLASS=keytype>bool</font> bufavail()  { <font CLASS=keyword>return</font> savecount &gt; <font CLASS=integer>0</font>; }
    <font CLASS=keytype>void</font> post(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);
    <font CLASS=keytype>void</font> post(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* s);
    <font CLASS=keytype>void</font> post(<font CLASS=keytype>char</font> c);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> post(string s);

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    infilter(instm* istm, <font CLASS=keytype>int</font> ibufsize <font CLASS=symbols>=</font> <font CLASS=symbols>-</font><font CLASS=integer>1</font>);
    <font CLASS=keyword>virtual</font> ~infilter();

    <font CLASS=keyword>virtual</font> string get_errstmname();

    instm* get_stm()  { <font CLASS=keyword>return</font> stm; }
    <font CLASS=keytype>void</font> set_stm(instm* stm);
};


<font CLASS=comment>//</font>
<font CLASS=comment>// abstract output filter class</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> outfilter: public outstm
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    outstm* stm;
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> freenotify(component* sender);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    outfilter(outstm* istm, <font CLASS=keytype>int</font> ibufsize <font CLASS=symbols>=</font> <font CLASS=symbols>-</font><font CLASS=integer>1</font>);
    <font CLASS=keyword>virtual</font> ~outfilter();
    <font CLASS=keyword>virtual</font> string get_errstmname();
    outstm* get_stm()  { <font CLASS=keyword>return</font> stm; }
    <font CLASS=keytype>void</font> set_stm(outstm* stm);
};


<font CLASS=comment>//</font>
<font CLASS=comment>// inmemory - memory stream</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> inmemory: public instm 
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    string mem;
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> bufalloc();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> buffree();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> bufvalidate();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();
    <font CLASS=keyword>virtual</font> large doseek(large newpos, ioseekmode mode);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> dorawread(<font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    inmemory(<font CLASS=keyword>const</font> string&amp; imem);
    <font CLASS=keyword>virtual</font> ~inmemory();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> classid();
    <font CLASS=keyword>virtual</font> string get_streamname();
    large seekx(large newpos, ioseekmode mode <font CLASS=symbols>=</font> IO_BEGIN);
    <font CLASS=keytype>int</font> seek(<font CLASS=keytype>int</font> newpos, ioseekmode mode <font CLASS=symbols>=</font> IO_BEGIN)  { <font CLASS=keyword>return</font> convertoffset(seekx(newpos, mode)); }
    string get_strdata()  { <font CLASS=keyword>return</font> mem; }
    <font CLASS=keytype>void</font> set_strdata(<font CLASS=keyword>const</font> string&amp; data);
};


<font CLASS=comment>//</font>
<font CLASS=comment>// outmemory - memory stream</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> outmemory: public outstm 
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    string mem;
    <font CLASS=keytype>int</font> limit;

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();
    <font CLASS=keyword>virtual</font> large doseek(large newpos, ioseekmode mode);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> dorawwrite(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    outmemory(<font CLASS=keytype>int</font> limit <font CLASS=symbols>=</font> <font CLASS=symbols>-</font><font CLASS=integer>1</font>);
    <font CLASS=keyword>virtual</font> ~outmemory();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> classid();
    <font CLASS=keyword>virtual</font> string get_streamname();
    large tellx()               { <font CLASS=keyword>return</font> abspos; }
    <font CLASS=keytype>int</font> tell()                  { <font CLASS=keyword>return</font> (<font CLASS=keytype>int</font>)abspos; }
    string get_strdata();
};


<font CLASS=comment>// -------------------------------------------------------------------- //</font>
<font CLASS=comment>// ---  file input/output --------------------------------------------- //</font>
<font CLASS=comment>// -------------------------------------------------------------------- //</font>


<font CLASS=comment>//</font>
<font CLASS=comment>// infile - file input</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> outfile;

<font CLASS=keyword>class</font> infile: public instm
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    string filename;
    <font CLASS=keytype>int</font>    syshandle;   <font CLASS=comment>// if not -1, assigned to handle in open() instead of opening a file by a name</font>
    <font CLASS=keytype>int</font>    peerhandle;  <font CLASS=comment>// pipe peer handle, needed for closing the peer after fork() on unix</font>

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    infile();
    infile(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* ifn);
    infile(<font CLASS=keyword>const</font> string&amp; ifn);
    <font CLASS=keyword>virtual</font> ~infile();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> classid();

    <font CLASS=keytype>void</font> pipe(outfile&amp;);
    <font CLASS=keyword>virtual</font> string get_streamname();
    <font CLASS=keytype>int</font> get_syshandle()                     { <font CLASS=keyword>return</font> syshandle; }
    <font CLASS=keytype>void</font> set_syshandle(<font CLASS=keytype>int</font> ihandle)         { close(); syshandle <font CLASS=symbols>=</font> ihandle; }
    <font CLASS=keytype>int</font> get_peerhandle()                    { <font CLASS=keyword>return</font> peerhandle; }
    string get_filename()                   { <font CLASS=keyword>return</font> filename; }
    <font CLASS=keytype>void</font> set_filename(<font CLASS=keyword>const</font> string&amp; ifn)    { close(); filename <font CLASS=symbols>=</font> ifn; }
    <font CLASS=keytype>void</font> set_filename(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* ifn)      { close(); filename <font CLASS=symbols>=</font> ifn; }
};


<font CLASS=comment>//</font>
<font CLASS=comment>// outfile - file output</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> outfile: public outstm
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    <font CLASS=keyword>friend</font> <font CLASS=keyword>class</font> infile; <font CLASS=comment>// infile::pipe() needs access to peerhandle</font>

    string filename;
    <font CLASS=keytype>int</font>    syshandle;   <font CLASS=comment>// if not -1, assigned to handle in open() instead of opening a file by a name</font>
    <font CLASS=keytype>int</font>    peerhandle;  <font CLASS=comment>// pipe peer handle, needed for closing the peer after fork() on unix</font>
    <font CLASS=keytype>int</font>    umode;       <font CLASS=comment>// unix file mode (unix only), default = 644</font>
    <font CLASS=keytype>bool</font>   append;      <font CLASS=comment>// append (create new if needed), default = false</font>

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    outfile();
    outfile(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* ifn, <font CLASS=keytype>bool</font> iappend <font CLASS=symbols>=</font> <font CLASS=keyword>false</font>);
    outfile(<font CLASS=keyword>const</font> string&amp; ifn, <font CLASS=keytype>bool</font> iappend <font CLASS=symbols>=</font> <font CLASS=keyword>false</font>);
    <font CLASS=keyword>virtual</font> ~outfile();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> classid();

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> flush();
    <font CLASS=keyword>virtual</font> string get_streamname();

    <font CLASS=keytype>int</font> get_syshandle()                     { <font CLASS=keyword>return</font> syshandle; }
    <font CLASS=keytype>void</font> set_syshandle(<font CLASS=keytype>int</font> ihandle)         { close(); syshandle <font CLASS=symbols>=</font> ihandle; }
    <font CLASS=keytype>int</font> get_peerhandle()                    { <font CLASS=keyword>return</font> peerhandle; }
    string get_filename()                   { <font CLASS=keyword>return</font> filename; }
    <font CLASS=keytype>void</font> set_filename(<font CLASS=keyword>const</font> string&amp; ifn)    { close(); filename <font CLASS=symbols>=</font> ifn; }
    <font CLASS=keytype>void</font> set_filename(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* ifn)      { close(); filename <font CLASS=symbols>=</font> ifn; }
    <font CLASS=keytype>bool</font> get_append()                       { <font CLASS=keyword>return</font> append; }
    <font CLASS=keytype>void</font> set_append(<font CLASS=keytype>bool</font> iappend)           { close(); append <font CLASS=symbols>=</font> iappend; }
    <font CLASS=keytype>int</font>  get_umode()                        { <font CLASS=keyword>return</font> umode; }
    <font CLASS=keytype>void</font> set_umode(<font CLASS=keytype>int</font> iumode)              { close(); umode <font CLASS=symbols>=</font> iumode; }
};


<font CLASS=comment>//</font>
<font CLASS=comment>// logfile - file output with thread-safe putf()</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> logfile: public outfile
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
<font CLASS=preproc>#ifndef</font> PTYPES_ST 
    mutex lock;
<font CLASS=preproc>#endif</font> 
<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    logfile();
    logfile(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* ifn, <font CLASS=keytype>bool</font> iappend <font CLASS=symbols>=</font> <font CLASS=keyword>true</font>);
    logfile(<font CLASS=keyword>const</font> string&amp; ifn, <font CLASS=keytype>bool</font> iappend <font CLASS=symbols>=</font> <font CLASS=keyword>true</font>);
    <font CLASS=keyword>virtual</font> ~logfile();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> classid();

    <font CLASS=keytype>void</font> vputf(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* fmt, va_list);
    <font CLASS=keytype>void</font> putf(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* fmt, ...);
};


<font CLASS=comment>//</font>
<font CLASS=comment>// intee - UNIX tee-style utility class</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>class</font> intee: public infilter {
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    outfile file;
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> dofilter();
<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    intee(instm* istm, <font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* ifn, <font CLASS=keytype>bool</font> iappend <font CLASS=symbols>=</font> <font CLASS=keyword>false</font>);
    intee(instm* istm, <font CLASS=keyword>const</font> string&amp; ifn, <font CLASS=keytype>bool</font> iappend <font CLASS=symbols>=</font> <font CLASS=keyword>false</font>);
    <font CLASS=keyword>virtual</font> ~intee();

    outfile* get_file()   { <font CLASS=keyword>return</font> &amp;file; }
    <font CLASS=keyword>virtual</font> string get_streamname();
};


<font CLASS=comment>// -------------------------------------------------------------------- //</font>
<font CLASS=comment>// ---  named pipes --------------------------------------------------- //</font>
<font CLASS=comment>// -------------------------------------------------------------------- //</font>


<font CLASS=comment>// on Unix this directory can be overridden by providing the</font>
<font CLASS=comment>// full path, e.g. '/var/run/mypipe'. the path is ignored on </font>
<font CLASS=comment>// Windows and is always replaced with '\\&lt;server&gt;\pipe\'</font>

<font CLASS=preproc>#ifndef</font> WIN32 
<font CLASS=preproc>#</font>  define DEF_NAMED_PIPES_DIR <font CLASS=dblquot>"/tmp/"</font> 
<font CLASS=preproc>#endif</font> 


<font CLASS=preproc>#ifdef</font> WIN32 

<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> DEF_PIPE_TIMEOUT <font CLASS=symbols>=</font> <font CLASS=integer>20000</font>;         <font CLASS=comment>// in milliseconds, for reading and writing</font>
<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> DEF_PIPE_OPEN_TIMEOUT <font CLASS=symbols>=</font> <font CLASS=integer>1000</font>;     <font CLASS=comment>// for connecting to the remote pipe:</font>
<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> DEF_PIPE_OPEN_RETRY <font CLASS=symbols>=</font> <font CLASS=integer>5</font>;          <font CLASS=comment>//    will double the timeout value for each retry,</font>
                                            <font CLASS=comment>//    i.e. 1 second, then 2, then 4 etc.</font>
<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> DEF_PIPE_SYSTEM_BUF_SIZE <font CLASS=symbols>=</font> <font CLASS=integer>4096</font>;

<font CLASS=preproc>#endif</font> 


<font CLASS=keyword>class</font> namedpipe: public fdxstm
{
    <font CLASS=keyword>friend</font> <font CLASS=keyword>class</font> npserver;

<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    string pipename;
    <font CLASS=keytype>int</font>    svhandle;

<font CLASS=preproc>#ifdef</font> WIN32 
    // we use overlapped IO in order to have timed waiting in serve()
    // and also to implement timeout error on the client side
    OVERLAPPED ovr;
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> dorawread(<font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> dorawwrite(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);
    <font CLASS=keytype>static</font> string realpipename(<font CLASS=keyword>const</font> string&amp; pipename, <font CLASS=keyword>const</font> string&amp; svrname <font CLASS=symbols>=</font> nullstring);
    <font CLASS=keytype>void</font> initovr();
<font CLASS=preproc>#else</font> 
    <font CLASS=keytype>static</font> string realpipename(<font CLASS=keyword>const</font> string&amp; pipename);
    <font CLASS=keytype>static</font> <font CLASS=keytype>bool</font> setupsockaddr(<font CLASS=keyword>const</font> string&amp; pipename, <font CLASS=keytype>void</font>* sa);
    <font CLASS=keytype>void</font> initovr()  {}
<font CLASS=preproc>#endif</font> 

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();
    <font CLASS=keyword>virtual</font> large doseek(large, ioseekmode);

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    namedpipe();
    namedpipe(<font CLASS=keyword>const</font> string&amp; ipipename);
<font CLASS=preproc>#ifdef</font> WIN32 
    namedpipe(<font CLASS=keyword>const</font> string&amp; ipipename, <font CLASS=keyword>const</font> string&amp; servername);
<font CLASS=preproc>#endif</font> 
    <font CLASS=keyword>virtual</font> ~namedpipe();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> classid();

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> flush();
    <font CLASS=keyword>virtual</font> string get_streamname();

    string get_pipename()   { <font CLASS=keyword>return</font> pipename; }
    <font CLASS=keytype>void</font> set_pipename(<font CLASS=keyword>const</font> string&amp;);
    <font CLASS=keytype>void</font> set_pipename(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>*);
};


<font CLASS=keyword>class</font> npserver: public unknown
{
    string pipename;
    <font CLASS=keytype>int</font>    handle;
    <font CLASS=keytype>bool</font>   active;

    <font CLASS=keytype>void</font> error(<font CLASS=keytype>int</font> code, <font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* defmsg);
    <font CLASS=keytype>void</font> open();
    <font CLASS=keytype>void</font> close();
<font CLASS=preproc>#ifdef</font> WIN32 
    <font CLASS=keytype>void</font> openinst();
    <font CLASS=keytype>void</font> closeinst();
<font CLASS=preproc>#endif</font> 

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    npserver(<font CLASS=keyword>const</font> string&amp; ipipename);
    ~npserver();

    <font CLASS=keytype>bool</font> serve(namedpipe&amp; client, <font CLASS=keytype>int</font> timeout <font CLASS=symbols>=</font> <font CLASS=symbols>-</font><font CLASS=integer>1</font>);
};


<font CLASS=comment>// -------------------------------------------------------------------- //</font>
<font CLASS=comment>// ---  utility streams ----------------------------------------------- //</font>
<font CLASS=comment>// -------------------------------------------------------------------- //</font>

<font CLASS=comment>//</font>
<font CLASS=comment>// MD5 -- message digest algorithm</font>
<font CLASS=comment>// Derived from L. Peter Deutsch's work, please see src/pmd5.cxx</font>
<font CLASS=comment>//</font>


<font CLASS=keyword>const</font> <font CLASS=keytype>int</font> md5_digsize <font CLASS=symbols>=</font> <font CLASS=integer>16</font>;
<font CLASS=keyword>typedef</font> uchar md5_digest[md5_digsize];

<font CLASS=comment>// from md5.h</font>

<font CLASS=keyword>typedef</font> <font CLASS=keytype>unsigned</font> <font CLASS=keytype>char</font> md5_byte_t; <font CLASS=comment>/* 8-bit byte */</font>
<font CLASS=keyword>typedef</font> <font CLASS=keytype>unsigned</font> <font CLASS=keytype>int</font> md5_word_t; <font CLASS=comment>/* 32-bit word */</font>


<font CLASS=keyword>typedef</font> <font CLASS=keyword>struct</font> md5_state_s
{
    md5_word_t count[<font CLASS=integer>2</font>];	<font CLASS=comment>/* message length in bits, lsw first */</font>
    md5_word_t abcd[<font CLASS=integer>4</font>];		<font CLASS=comment>/* digest buffer */</font>
    md5_byte_t buf[<font CLASS=integer>64</font>];		<font CLASS=comment>/* accumulate block */</font>
} md5_state_t;


<font CLASS=keyword>class</font> outmd5: public outfilter
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    md5_state_s ctx;
    md5_digest digest;

    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> dorawwrite(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>* buf, <font CLASS=keytype>int</font> count);

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    outmd5(outstm* istm <font CLASS=symbols>=</font> nil);
    <font CLASS=keyword>virtual</font> ~outmd5();
    
    <font CLASS=keyword>virtual</font> string get_streamname();

    <font CLASS=keyword>const</font> <font CLASS=keytype>unsigned</font> <font CLASS=keytype>char</font>* get_bindigest()  { close(); <font CLASS=keyword>return</font> digest; }
    string get_digest();
};


<font CLASS=comment>//</font>
<font CLASS=comment>// null output stream</font>
<font CLASS=comment>//</font>


<font CLASS=keyword>class</font> outnull: public outstm
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font>  dorawwrite(<font CLASS=keyword>const</font> <font CLASS=keytype>char</font>*, <font CLASS=keytype>int</font>);
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doopen();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> doclose();
<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    outnull();
    <font CLASS=keyword>virtual</font> ~outnull();
    <font CLASS=keyword>virtual</font> string get_streamname();
};


<font CLASS=comment>// -------------------------------------------------------------------- //</font>
<font CLASS=comment>// ---  unit ---------------------------------------------------------- //</font>
<font CLASS=comment>// -------------------------------------------------------------------- //</font>


<font CLASS=preproc>#ifdef</font> _MSC_VER 
<font CLASS=comment>// disable "type name first seen using 'struct' now seen using 'class'" warning</font>
<font CLASS=preproc>#</font>  pragma warning (disable: <font CLASS=integer>4099</font>) 
<font CLASS=comment>// disable "class '...' needs to have dll-interface to be used by clients of class </font>
<font CLASS=comment>// '...'" warning, since the compiler may sometimes give this warning incorrectly.</font>
<font CLASS=preproc>#</font>  pragma warning (disable: <font CLASS=integer>4251</font>) 
<font CLASS=preproc>#endif</font> 

<font CLASS=keyword>class</font> unit_thread;

<font CLASS=keyword>class</font> unit: public component
{
<font CLASS=preproc><font CLASS=keyword>protected</font>:</font>
    <font CLASS=keyword>friend</font> <font CLASS=keyword>class</font> unit_thread;

    unit*         pipe_next;    <font CLASS=comment>// next unit in the pipe chain, assigned by connect()</font>
    unit_thread*  main_thread;  <font CLASS=comment>// async execution thread, started by run() if necessary</font>
    <font CLASS=keytype>int</font>           running;      <font CLASS=comment>// running status, to protect from recursive calls to run() and waitfor()</font>

    <font CLASS=keytype>void</font> do_main();

<font CLASS=preproc><font CLASS=keyword>public</font>:</font>
    compref&lt;instm&gt; uin;
    compref&lt;outstm&gt; uout;

    unit();
    <font CLASS=keyword>virtual</font> ~unit();
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>int</font> classid();

    // things that may be overridden in descendant classes
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> main();        <font CLASS=comment>// main code, called from run()</font>
    <font CLASS=keyword>virtual</font> <font CLASS=keytype>void</font> cleanup();     <font CLASS=comment>// main code cleanup, called from run()</font>

    // service methods
    <font CLASS=keytype>void</font> connect(unit* next);
    <font CLASS=keytype>void</font> run(<font CLASS=keytype>bool</font> async <font CLASS=symbols>=</font> <font CLASS=keyword>false</font>);
    <font CLASS=keytype>void</font> waitfor();
};
<font CLASS=keyword>typedef</font> unit* punit;


<font CLASS=keyword>typedef</font> unit CUnit;         <font CLASS=comment>// send me a $10 check if you use this alias (not obligatory though,</font>
                            <font CLASS=comment>// because the library is free, after all)</font>


<font CLASS=comment>//</font>
<font CLASS=comment>// standard input, output and error devices</font>
<font CLASS=comment>//</font>

<font CLASS=keyword>extern</font> infile  pin;
<font CLASS=keyword>extern</font> logfile pout;
<font CLASS=keyword>extern</font> logfile perr;
<font CLASS=keyword>extern</font> outnull pnull;


<font CLASS=preproc>#ifdef</font> _MSC_VER 
<font CLASS=preproc>#pragma</font> pack(pop) 
<font CLASS=preproc>#endif</font> 


PTYPES_END

<font CLASS=preproc>#endif</font> <font CLASS=comment>// __PSTREAMS_H__ </font>




</pre>

</div>


<hr noshade></body>
</html>
